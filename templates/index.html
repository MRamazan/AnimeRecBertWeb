<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Recommendation System</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='greentheme.css') }}" id="theme-green" disabled>
    <link rel="stylesheet" href="{{ url_for('static', filename='orangetheme.css') }}" id="theme-orange" disabled>
    <link rel="stylesheet" href="{{ url_for('static', filename='purpletheme.css') }}" id="theme-purple">

    <style>
        /* Theme Switcher Styles */
        .theme-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .theme-switcher-toggle {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            border-radius: 10px;
            transition: all 0.3s ease;
            color: inherit;
        }

        .theme-switcher-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .theme-options {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .theme-options.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .theme-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 2px 0;
            font-size: 14px;
            font-weight: 500;
        }

        .theme-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        .theme-option.active {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .theme-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .theme-option.active .theme-color {
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .theme-purple .theme-color {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .theme-green .theme-color {
            background: linear-gradient(45deg, #4caf50, #2e7d32);
        }

        .theme-orange .theme-color {
            background: linear-gradient(45deg, #ffa500, #ff4500);
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .theme-switcher {
                top: 15px;
                right: 15px;
                padding: 6px;
            }

            .theme-switcher-toggle {
                font-size: 18px;
                padding: 6px;
            }

            .theme-options {
                right: -20px;
                min-width: 130px;
            }

            .theme-option {
                font-size: 13px;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Theme Switcher -->
    <div class="theme-switcher">
        <button class="theme-switcher-toggle" onclick="toggleThemeOptions()">üé®</button>
        <div class="theme-options" id="themeOptions">
            <div class="theme-option theme-purple active" onclick="changeTheme('purple')">
                <div class="theme-color"></div>
                <span>Purple</span>
            </div>
            <div class="theme-option theme-green" onclick="changeTheme('green')">
                <div class="theme-color"></div>
                <span>Green</span>
            </div>
            <div class="theme-option theme-orange" onclick="changeTheme('orange')">
                <div class="theme-color"></div>
                <span>Orange</span>
            </div>
        </div>
    </div>

    <button class="back-button" onclick="showFavorites()">‚Üê Back to Favorites</button>

    <div class="container">
        <div class="header">
            <h1>Just one episode...</h1>
            <p>Discover your next favorite anime</p>
        </div>

        <!-- Favorites Section -->
        <div class="favorites-section" id="favoritesSection">
            <h2 class="section-title">Select Your Favorite Animes</h2>

            <div class="search-container">
                <input type="text" class="search-input" id="animeSearch" placeholder="Search for an anime..." autocomplete="off">
                <span class="search-icon">üîç</span>
                <div class="anime-dropdown" id="animeDropdown"></div>
            </div>

            <div class="favorites-list" id="favoritesList">
                <div class="empty-state">No favorites selected yet. Search and add some animes!</div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" onclick="getRecommendations()">Get Recommendations</button>
                <button class="btn btn-secondary" onclick="clearFavorites()">Clear All</button>
            </div>
        </div>

        <!-- Recommendations Section -->
        <div class="recommendations-section" id="recommendationsSection">
            <div class="favorites-section">
                <h2 class="section-title">Recommended for You</h2>
                <div class="filter-container">
    <div class="filter-buttons">
    <button class="filter-btn" data-filter="show_sequels" onclick="toggleFilter(this)">Sequels
    </button>
    <button class="filter-btn active" data-filter="show_movies" onclick="toggleFilter(this)">Movies
    </button>
    <button class="filter-btn active" data-filter="show_tv" onclick="toggleFilter(this)">TV Series
    </button>
    <button class="filter-btn" data-filter="show_ova" onclick="toggleFilter(this)">OVA/ONA/SPECIAL
    </button>
</div>
    <button class="apply-filters-btn" onclick="applyFilters()">Apply Filters</button>
</div>
                <div class="recommendations-grid" id="recommendationsGrid"></div>
            </div>
        </div>
        <div class="about-section" id="aboutSection">
    <div class="about-content">
        <div class="about-item">
            <h3>About the Model</h3>
            <p>Despite its strong performance, I couldn't find any anime recommendation websites using a BERT-based recommender system. This recommendation system uses a BERT transformer specifically for anime recommendations. Unlike other systems, it takes only users' favorite anime titles as input, rather than ratings. I believe the BERT model handled the recommendation task very well.</p>
        </div>

        <div class="about-item">
            <h3>Purpose</h3>
            <p>This project was developed purely for entertainment, with the aim of helping people discover new anime and enjoy their viewing experience. At the same time, it serves as an experiment ‚Äî exploring how modern NLP models like BERT can be applied to reimagine recommendation systems. By shifting the focus from numeric ratings to users' actual favorites, the model seeks to capture deeper patterns of preference and better reflect individual taste.</p>
        </div>

        <div class="about-item">
    <h3>Contact & Feedback</h3>
    <p><a href="mailto:ramazanturan.dev@gmail.com">ramazanturan.dev@gmail.com</a></p>
</div>
        <div class="about-item">
    <h3>GitHub Repo</h3>
    <p><a href="https://github.com/MRamazan/AnimeRecBertWeb">https://github.com/MRamazan/AnimeRecBertWeb</a></p>
</div>
    </div>
</div>
    </div>

    <script>
        let allAnimes = [];
        let malLogoUrl = '';
        let currentTheme = 'purple';

        // Theme Switcher Functions
        function toggleThemeOptions() {
            const themeOptions = document.getElementById('themeOptions');
            themeOptions.classList.toggle('show');
        }

        function changeTheme(theme) {
            // Disable all theme stylesheets
            document.getElementById('theme-purple').disabled = true;
            document.getElementById('theme-green').disabled = true;
            document.getElementById('theme-orange').disabled = true;

            // Enable selected theme
            document.getElementById(`theme-${theme}`).disabled = false;

            // Update active theme option
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`.theme-${theme}`).classList.add('active');

            // Save theme preference
            localStorage.setItem('selectedTheme', theme);
            currentTheme = theme;

            // Hide theme options
            document.getElementById('themeOptions').classList.remove('show');
        }

        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('selectedTheme') || 'purple';
            changeTheme(savedTheme);
        }

        // Close theme options when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.theme-switcher')) {
                document.getElementById('themeOptions').classList.remove('show');
            }
        });

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadSavedTheme();
            loadFavorites();
            loadMalLogo();

            const searchInput = document.getElementById('animeSearch');
            const dropdown = document.getElementById('animeDropdown');

            searchInput.addEventListener('input', function() {
                const query = this.value.trim();
                if (query.length > 0) {
                    searchAnimes(query);
                } else {
                    hideDropdown();
                }
            });

            // Hide dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-container')) {
                    hideDropdown();
                }
            });
        });

        // Load MAL logo from backend
        async function loadMalLogo() {
            try {
                const response = await fetch('/api/mal_logo');
                const data = await response.json();
                if (data.success) {
                    malLogoUrl = data.logo_url;
                }
            } catch (error) {
                console.error('Error loading MAL logo:', error);
            }
        }

        // Search animes
        async function searchAnimes(query) {
            try {
                const response = await fetch(`/api/search_animes?q=${encodeURIComponent(query)}`);
                const animes = await response.json();
                showDropdown(animes);
            } catch (error) {
                console.error('Error searching animes:', error);
            }
        }

        // Show dropdown with search results
        function showDropdown(animes) {
    const dropdown = document.getElementById('animeDropdown');

    // Mevcut i√ßeriƒüi temizle
    dropdown.innerHTML = '';

    // Dropdown'u g√∂ster (opacity 0 ile)
    dropdown.style.display = 'block';

    // Kƒ±sa bir gecikme sonra i√ßeriƒüi y√ºkle
    setTimeout(() => {
        if (animes.length === 0) {
            dropdown.innerHTML = '<div class="anime-option">No animes found</div>';
        } else {
            animes.slice(0, 10).forEach(anime => {
                const option = document.createElement('div');
                option.className = 'anime-option';
                option.textContent = anime[1];
                option.onclick = () => addToFavorites(anime[0], anime[1]);
                dropdown.appendChild(option);
            });
        }

        // Show animasyonunu ba≈ülat
        dropdown.classList.add('show');
    }, 200);
}

// Hide dropdown - G√ºncellenmi≈ü versiyon
function hideDropdown() {
    const dropdown = document.getElementById('animeDropdown');
    dropdown.classList.remove('show');

    setTimeout(() => {
        dropdown.style.display = 'none';
        dropdown.innerHTML = ''; // ƒ∞√ßeriƒüi temizle
    }, 300);
}

        // Add anime to favorites
        async function addToFavorites(animeId, animeName) {
            try {
                const response = await fetch('/api/add_favorite', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        anime_id: animeId,
                        anime_name: animeName
                    })
                });

                const result = await response.json();

                if (result.success) {
                    loadFavorites();
                    document.getElementById('animeSearch').value = '';
                    hideDropdown();
                } else {
                    showMessage("Error", 'error');
                }
            } catch (error) {
                console.error('Error adding favorite:', error);
                showMessage('Error adding favorite', 'error');
            }
        }

        // Remove from favorites
        async function removeFromFavorites(animeId, animeName) {
            try {
                const response = await fetch('/api/remove_favorite', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        anime_id: animeId,
                        anime_name: animeName
                    })
                });

                const result = await response.json();

                if (result.success) {
                    loadFavorites();

                } else {
                    showMessage("Error", 'error');
                }
            } catch (error) {
                console.error('Error removing favorite:', error);
            }
        }

        // Load favorites from server
        async function loadFavorites() {
            try {
                const response = await fetch('/api/get_favorites');
                const favorites = await response.json();
                displayFavorites(favorites);
            } catch (error) {
                console.error('Error loading favorites:', error);
            }
        }

        // Display favorites
        function displayFavorites(favorites) {
            const favoritesList = document.getElementById('favoritesList');

            if (favorites.length === 0) {
                favoritesList.innerHTML = '<div class="empty-state">No favorites selected yet. Search and add some animes!</div>';
            } else {
                favoritesList.innerHTML = favorites.map(anime => `
                    <div class="favorite-tag">
                        <span>${anime.name}</span>
                        <button class="remove-btn" onclick="removeFromFavorites(${anime.id}, '${anime.name.replace(/'/g, "\\'")}')">√ó</button>
                    </div>
                `).join('');
            }
        }

        // Clear all favorites
        async function clearFavorites() {
            try {
                const response = await fetch('/api/clear_favorites', {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.success) {
                    loadFavorites();

                }
            } catch (error) {
                console.error('Error clearing favorites:', error);
            }
        }

        // Get recommendations
        async function getRecommendations() {
            const recommendationsSection = document.getElementById('recommendationsSection');
            const favoritesSection = document.getElementById('favoritesSection');
            const backButton = document.querySelector('.back-button');
            const recommendationsGrid = document.getElementById('recommendationsGrid');

            // Show loading
            recommendationsGrid.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <div>Getting your recommendations...</div>
                </div>
            `;

            // Hide favorites section and show recommendations
            favoritesSection.style.display = 'none';
            recommendationsSection.style.display = 'block';
            backButton.style.display = 'block';

            try {
                const response = await fetch('/api/get_recommendations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        filters: currentFilters
                    })
                });

                const result = await response.json();

                if (result.success) {
                    displayRecommendations(result.recommendations);
                } else {
                    recommendationsGrid.innerHTML = `
                        <div class="loading">
                            <div style="color: #ff6b6b;">${result.message}</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error getting recommendations:', error);
                recommendationsGrid.innerHTML = `
                    <div class="loading">
                        <div style="color: #ff6b6b;">Error getting recommendations</div>
                    </div>
                `;
            }
        }

        // Display recommendations
        function displayRecommendations(recommendations) {
            const recommendationsGrid = document.getElementById('recommendationsGrid');

            if (recommendations.length === 0) {
                recommendationsGrid.innerHTML = '<div class="loading">No recommendations found</div>';
                return;
            }

            recommendationsGrid.innerHTML = recommendations.map((anime, index) => {
                const imageElement = anime.image_url
                    ? `<img src="${anime.image_url}" alt="${anime.name}" class="anime-image" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">`
                    : '';

                const placeholderElement = anime.image_url
                    ? `<div class="no-image-placeholder" style="display: none;">üéå</div>`
                    : `<div class="no-image-placeholder">üéå</div>`;

                const malButton = anime.mal_url
                    ? `<a href="${anime.mal_url}" target="_blank" class="mal-button">
                        ${malLogoUrl ? `<img src="${malLogoUrl}" alt="MAL" class="mal-logo">` : 'üîó'}
                        View on MyAnimeList
                       </a>`
                    : `<div class="mal-message">MyAnimeList link not available</div>`;

                return `
                    <div class="anime-card-wrapper" style="animation-delay: ${index * 0.1}s">
                        <div class="anime-rank"></div>
                        <div class="anime-card" onclick="flipCard(this)">
                            <div class="card-inner">
                                <div class="card-front">
                                    <div class="anime-image-container">
                                        ${imageElement}
                                        ${placeholderElement}

                                    </div>
                                    <div class="anime-info">
    <div class="anime-name">${anime.name}</div>
    <button class="already-watched-btn" onclick="addToFavoritesFromRecommendations(event, ${anime.id}, '${anime.name.replace(/'/g, "\\'")}')">
        Already Watched & Liked
    </button>
    <div class="flip-hint">Click card to see MyAnimeList link ‚Üí</div>
</div>
                                </div>
                                <div class="card-back">
                                    <div class="mal-button-container">
                                        ${malButton}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Flip card animation
        // Flip card animation
function flipCard(card) {
    const cardInner = card.querySelector('.card-inner');
    const scoreElement = card.querySelector('.anime-score');
    const buttonElement = card.querySelector('.already-watched-btn');

    if (cardInner.classList.contains('flipped')) {
        // Arka y√ºzden √∂n y√ºze √ßeviriliyor
        cardInner.classList.remove('flipped');

        // Score ve butonu gizle
        if (scoreElement) scoreElement.classList.add('hidden');
        if (buttonElement) buttonElement.classList.add('hidden');

        // 500ms sonra g√∂ster
        setTimeout(() => {
            if (scoreElement) scoreElement.classList.remove('hidden');
            if (buttonElement) buttonElement.classList.remove('hidden');
        }, 300);
    } else {
        // √ñn y√ºzden arka y√ºze √ßeviriliyor
        cardInner.classList.add('flipped');
    }

    // Prevent link click from flipping card
    const malButton = card.querySelector('.mal-button');
    if (malButton) {
        malButton.addEventListener('click', function(e) {
            e.stopPropagation();
        });
    }
}

        // Show favorites section
        function showFavorites() {
    document.getElementById('favoritesSection').style.display = 'block';
    document.getElementById('recommendationsSection').style.display = 'none';
    document.querySelector('.back-button').style.display = 'none';

    // Sayfayƒ± en √ºste kaydƒ±r
    window.scrollTo(0, 0);

}

        // Show messages
        function showMessage(message, type) {
            // Simple alert for now - you can replace with a better notification system
            alert(message);
        }
        // Add anime to favorites from recommendations
// Add anime to favorites from recommendations
async function addToFavoritesFromRecommendations(event, animeId, animeName) {
    // Prevent card flip when clicking button
    event.stopPropagation();

    try {
        const response = await fetch('/api/add_favorite', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                anime_id: animeId,
                anime_name: animeName
            })
        });

        const result = await response.json();

        if (result.success) {


                showFavorites();
                loadFavorites();

                getRecommendations();

        } else {
            showMessage("This anime is already in your favorites!", 'info');
        }
    } catch (error) {
        console.error('Error adding favorite:', error);
        showMessage('Error adding to favorites', 'error');
    }
}
        let currentFilters = {
    show_sequels: false,
    show_movies: true,
    show_tv: true,
    show_ova: false
};

function toggleFilter(button) {
    const filterName = button.getAttribute('data-filter');
    const isActive = button.classList.contains('active');

    if (isActive) {
        button.classList.remove('active');
        currentFilters[filterName] = false;
    } else {
        button.classList.add('active');
        currentFilters[filterName] = true;
    }
}

function applyFilters() {
    getRecommendations();
}
    </script>

</body>
</html>
